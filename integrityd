#!/usr/bin/perl
use strict;
use warnings;
# Copyright (C) 2011  Glen Pitt-Pladdy
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
#
#
# See: https://www.pitt-pladdy.com/blog/_20120407-220642_0000_Background_files_integrity_and_log_auditing_fcheck_logcheck_/


# use with logcheck-database (debian)


my $VERSION = 20140314;


use DBI;	# TODO only if filesystem checks are enabled TODO
use Digest::HMAC_SHA1;
use Time::HiRes qw(usleep gettimeofday);
use List::Util qw(shuffle);
use Sys::Hostname;
use Sys::Syslog;
use Proc::Daemon;
#use Fcntl qw(:DEFAULT O_DIRECT);
#use IO::AIO qw(fadvise FADV_SEQUENTIAL FADV_NOREUSE FADV_DONTNEED);	# debian: libio-aio-perl
use IO::AIO;	# debian: libio-aio-perl - need wheezy or later



# get logging online
my $logname = $0;
$logname =~ s/^.*\///;
openlog ( $logname, 'ndelay,pid', 'local0' );
syslog ( 'info', 'Starting up with arguments: '.join(' ',@ARGV) );


# set command / arguments
$0 = __FILE__.' '.join(' ',@ARGV);


my $DAEMON = 1;
my $PIDFILE = '/var/run/integrityd.pid';
my $MAIL = '/usr/bin/mail';
my $TRANSACTIONPOOL = 100;	# wrap files in a transaction at this rate


my $CONFIG = '/etc/integrityd.conf';
my $email = 'root@localhost';	# TODO if this is set to '' or NULL then no email alerting TODO
my $database = '/var/lib/integrityd/integrityd.sqlite';
my $byterate = 1048576;    # Bytes / second
my $filerate = 1;    # Files / second
my $speedup = 20;	# speed up when changes / emptydb
my $smallfiles = 131072;	# don't trickle reading files smaller than this for checksums
my $filechangeaction;	# TODO run this commnad (none by default) on every changed file TODO with environment describing the change
my $reporttime = 30;	# pool changes for this long before sending
my $reportholdoff = 300;	# wait this long after a report before sending again
my %areas;
my %excludes;
my $logchecktime = 30;
my $logruleupdate = 120;
my $logreporttime = 0;
my $logreportholdoff = 0;
my $logrules = '/etc/logcheck';	# applies to subsequent "log" entries
my %logfiles;
my @logfiles;
my $pidct = 100;		# applies to subsequent "pidfile" entries
my %pidfiles;	# CT and PID file
my $pidchecktime = 30;

my %logrules;	# the rules areas we need to watch
my %logrulestimes;	# times
my %logrulesexpressions;	# rules for each area

# Nagios passive check info
my $nagioscmd;			# nagios reporting disabled if this is not set
my $nagiosexpire = 900;	# alert for 15 minutes by default
my $nagiosping = 30;	# how often to ping Nagios
my $nagioshost = '';	# applies to subsequent checks - if empty no reporting is done
my $nagiosdescription;	# applies to subsequent checks - defaults to filecheck|logcheck|pidcheck
my %areasnagioshost;
my %areasnagiosdescription;
my %logsnagioshost;
my %logsnagiosdescription;
my %pidsnagioshost;
my %pidsnagiosdescription;


# Read in the config
# Everything up to this point may be overridden by the config
# Now that we have the basics down, override them with the config
if ( -f $CONFIG ) {
	open my $inc, '<', $CONFIG or die "$0: FATAL - can't read config: $!\n";
	while ( defined ( my $line = <$inc> ) ) {
		chomp $line;
		if ( $line =~ /#/ or $line =~ /^\s*$/ ) { next; }
		if ( $line =~ /^(\w+)\s*=\s*([^\s].*)$/ ) {
			if ( $1 eq 'email' ) {
				$email = $2;
			} elsif ( $1 eq 'database' ) {
				$database = $2;
			} elsif ( $1 eq 'byterate' ) {
				$byterate = $2;
			} elsif ( $1 eq 'filerate' ) {
				$filerate = $2;
			} elsif ( $1 eq 'speedup' ) {
				$speedup = $2;
			} elsif ( $1 eq 'smallfiles' ) {
				$smallfiles = $2;
			} elsif ( $1 eq 'filechangeaction' ) {
				$filechangeaction = $2;
				if ( ! -x $filechangeaction ) {
					die "$0: can't execute 'filechangeaction': $$filechangeaction\n";
				}
			} elsif ( $1 eq 'logchecktime' ) {
				$logchecktime = $2;
			} elsif ( $1 eq 'logruleupdate' ) {
				$logruleupdate = $2;
			} elsif ( $1 eq 'pidchecktime' ) {
				$pidchecktime = $2;
			} elsif ( $1 eq 'reporttime' ) {
				$reporttime = $2;
			} elsif ( $1 eq 'reportholdoff' ) {
				$reportholdoff = $2;
			} elsif ( $1 eq 'logreporttime' ) {
				$logreporttime = $2;
			} elsif ( $1 eq 'logreportholdoff' ) {
				$logreportholdoff = $2;
			} elsif ( $1 eq 'nagioscmd' ) {
				$nagioscmd = $1;
			} elsif ( $1 eq 'nagiosexpire' ) {
				$nagiosexpire = $1;
			} elsif ( $1 eq 'nagiosping' ) {
				$nagiosping = $1;
			} elsif ( $1 eq 'nagioshost' ) {
				$nagioshost = $1;
			} elsif ( $1 eq 'nagiosdescription' ) {
				$nagiosdescription = $1;
			} elsif ( $1 eq 'area' ) {
				my $path = $2;
				$path =~ s/(.)\/$/$1/;	# strip trailing /
				$areas{$path} = 1;
				# nagios parameters
				if ( $nagioshost ne '' ) { $areasnagioshost{$path} = $nagioshost; }
				$areasnagiosdescription{$path} = (defined $nagiosdescription and $nagiosdescription ne '')?$nagioshost:'filecheck';
			} elsif ( $1 eq 'exclude' ) {
				$excludes{$2} = 1;
			} elsif ( $1 eq 'logrules' ) {
				$logrules = $2;
			} elsif ( $1 eq 'log' ) {
				$logfiles{$2} = $logrules;
				push @logfiles, $2;
				$logrules{$logrules} = 1;
				# nagios parameters
				if ( $nagioshost ne '' ) { $logsnagioshost{$2} = $nagioshost; }
				$logsnagiosdescription{$2} = (defined $nagiosdescription and $nagiosdescription ne '')?$nagioshost:'logcheck';
			} elsif ( $1 eq 'pidfile' ) {
				$pidfiles{$pidct}{$2} = 1;
				# nagios parameters
				if ( $nagioshost ne '' ) { $logsnagioshost{$2} = $nagioshost; }
				$pidsnagiosdescription{$2} = (defined $nagiosdescription and $nagiosdescription ne '')?$nagioshost:'pidcheck';
			} elsif ( $1 eq 'pidct' ) {
				$pidct = $2;
			} else {
				die "$0: Don't understand config line: $line\n";
			}
		} else {
			die "$0: Don't understand config line: $line\n";
		}
	}
	close $inc;
}
# set defaults if none already set
if ( $logreporttime == 0 ) { $logreporttime = $reporttime; }
if ( $logreportholdoff == 0 ) { $logreportholdoff = $reportholdoff; }

# check our state
my $emptydb = 0;
my $speedfactor = $speedup;	# always start at max speed
if ( defined $ARGV[0] and $ARGV[0] eq '--emptydb' ) {
	$emptydb = 1;
	syslog 'info', 'Started in empty database mode - skipping reporting and old node checks unil database is populated';
}


# we're all ready to go - daemonise if needed
if ( $DAEMON ) {
	if ( -f $PIDFILE ) {
		die "$0: FATAL - pid file \"$PIDFILE\" already exists\n";
	}
	# daemonise
	my $ret = Proc::Daemon::Init ();
	if ( ! defined $ret ) {
		syslog 'err', "FATAL - failed to fork()";
		die "$0: FATAL - failed to fork()\n";
	} elsif ( $ret > 0 ) {
		# we are the parent - no need to go further
		exit 0;
	}
	# we are the child (daemon)
	# get the PID sorted
	my $pid;
	if ( ! open $pid, '>', $PIDFILE ) {
		syslog 'err', "FATAL - can't write \"$PIDFILE\": $!";
		die "$0: FATAL - can't write \"$PIDFILE\": $!\n";
	}
	print $pid $$;
	close $pid;
	# looking good
	syslog 'info', 'Successfully daemonised';
}
# set signal hanlder
$SIG{'TERM'} = 'exitclean';
$SIG{'QUIT'} = 'exitclean';
$SIG{'INT'} = 'exitclean';
$SIG{'HUP'} = 'exitclean';


# get database up TODO use and enable this on demand TODO
my $dbh = DBI->connect ( "DBI:SQLite:dbname=$database",'','',{RaiseError=>+1,AutoCommit=>1} ) or die "Can't connect: ".$DBI::errstr;
# these shave about 10-15% off
$dbh->do ( 'PRAGMA cache_size = 100000' );
$dbh->do ( 'PRAGMA synchronous = OFF' );
$dbh->do ( 'PRAGMA temp_store = MEMORY' );
$dbh->do ( 'PRAGMA count_changes = OFF' );
$dbh->{AutoCommit} = 0;

#$dbh->trace(2);
# check state of database
my $st = $dbh->prepare ( 'SELECT COUNT(*) FROM NodeInfo' );
$st->execute ();
my $result = $st->fetchrow_hashref ();
if ( $$result{'COUNT(*)'} == 0 ) {
	$emptydb = 1;
	$speedfactor = $speedup;
	syslog ( 'info', 'Empty database found - skipping reporting and old node checks unil database is populated' );
}

# make sure entries are in database for current log files
my $qstr = '';
my @files;
foreach my $logfile (keys %logfiles) {
	$st = $dbh->prepare ( 'INSERT OR IGNORE INTO LogPosition (LogFile,Inode,Position) VALUES (?,0,0)' );
	$st->execute ( $logfile );
	if ( $qstr eq '' ) {
		$qstr .= '?';
	} else {
		$qstr .= ',?';
	}
	push @files, $logfile;
}
# clear out old LogPostition entries (logs not in config)
$st = $dbh->prepare ( 'DELETE FROM LogPosition Where LogFile NOT IN ('.$qstr.')' );
$st->execute ( @files );
# make sure entries are in database for current pid files
$qstr = '';
undef @files;
foreach my $ct (keys %pidfiles) {
	foreach my $file (keys %{$pidfiles{$ct}}) {
		$st = $dbh->prepare ( 'INSERT OR IGNORE INTO PID (File,HostPID,CT,CTPID,PidFileExists,Alive) VALUES (?,0,?,0,0,0)' );
		$st->execute ( $file, $ct );
		if ( $qstr eq '' ) {
			$qstr .= '?';
		} else {
			$qstr .= ',?';
		}
		push @files, $file;
	}
}
# clear out old PID entries (pid files not in config)
$st = $dbh->prepare ( 'DELETE FROM PID Where File NOT IN ('.$qstr.')' );
$st->execute ( @files );
# commit database prep
$dbh->commit();

# measure how long each cycle takes
my $cycletime;

# get log rules onboard
checklogrules ();

# flush any reports
my $lastreport = 0;	# most recent report
my $oldestreport = 1;
sendfilereport ();
$lastreport = 0;	# reset to start
my $loglastreport = 0;	# most recent report
my $logoldestreport = 1;
sendlogreport ();
$loglastreport = 0;	# reset to start


# main loop
my $run = 1;
my $lastlogruleupdate = $^T;
my $lastlogcheck = $^T - $logchecktime;
my $lastpidcheck = $^T - $pidchecktime;
my $commitcount = 0;
while ( $run ) {
	my $runtime = gettimeofday ();
	my $nodecount = 0;
	my $totalsize = 0;
	my $reshuffle = 0;
	my $reshuffleat = rand() * 100;
	my @searchstack;
	my $filechangecount = 0;
	# put initial listings in to help mix it up
	foreach (keys %areas) {
		push @searchstack, glob "$_/*";
		my ( $changed, $size ) = checknode ( $_ );
		$filechangecount += $changed;
	}
	@searchstack = shuffle @searchstack;
	# search this area
	while ( scalar ( @searchstack ) > 0 and $run ) {
		my $node = pop @searchstack;
		if ( defined $excludes{$node} ) { next; }
		# process this node
		my ( $changed, $size ) = checknode ( $node );
		$filechangecount += $changed;
		# add more if needed
		if ( -d $node and ! -l $node ) {
			push @searchstack, glob "$node/*";
			@searchstack = shuffle @searchstack;
		}
		# do delay
		$totalsize += $size;
		++$nodecount;
		my $reqdelay = $nodecount / ( $filerate * $speedfactor ) + $totalsize / ( $byterate * $speedfactor ) + $runtime - gettimeofday ();
		if ( $reqdelay > 0 ) { usleep ( $reqdelay * 1000000 ); }
			else { $runtime -= $reqdelay; }
		# check longest node in DB
		if ( ! $emptydb ) {	# skip on first run
			$st = $dbh->prepare ( 'SELECT Path FROM NodeInfo ORDER BY LastChecked LIMIT 1' );
			$st->execute ();
			$result = $st->fetchrow_hashref ();
			$size = 0;
			if ( defined $$result{'Path'} ) {
				# work out exclusions
				my $excluded = 1;
				my @parts = split '/', $$result{'Path'};
				if ( $parts[0] eq '' ) { shift @parts; }
				my $path = '';
				if ( defined $areas{'/'} ) { $excluded = 0; }
#print STDERR "$$result{Path} > $excluded\n";
				foreach (@parts) {
					$path .= "/$_";
#print STDERR "$path # ".((defined $areas{$path})?1:0)."\n";
#print STDERR "$path ## ".((defined $excludes{$path})?1:0)."\n";
#print STDERR "$path > $excluded\n";
					if ( defined $areas{$path} ) { $excluded = 0; }
#print STDERR "$path >> $excluded\n";
					if ( defined $excludes{$path} ) { $excluded = 1; }
#print STDERR "$path >>> $excluded\n";
				}
				# now we should know if it's excluded
				if ( $excluded ) {
					$st = $dbh->prepare ( 'DELETE FROM NodeInfo WHERE Path = ?' );
					$st->execute ( $$result{'Path'} );
#print STDERR "\n\n\n************** DELETED $$result{Path} ******************\n\n\n\n";
				} else {
					my ( $changed, $size ) = checknode ( $node );
					$filechangecount += $changed;
				}
			}
			# do delay
			$totalsize += $size;
			++$nodecount;
			$reqdelay = $nodecount / ( $filerate * $speedfactor ) + $totalsize / ( $byterate * $speedfactor ) + $runtime - gettimeofday ();
			if ( $reqdelay > 0 ) { usleep ( $reqdelay * 1000000 ); }
				else { $runtime -= $reqdelay; }
		}
		# shuffle order periodically to reduce predictability
		if ( ++$reshuffle > $reshuffleat ) {
			@searchstack = shuffle @searchstack;
			$reshuffle = 0;
			$reshuffleat = rand() * 100;
		}
		# run other cycles
		cyclecheck ();

		# send reports
		sendfilereport ();
		# commit to database if needed
		if ( $commitcount++ >= $TRANSACTIONPOOL ) {
			$dbh->commit();
			$commitcount = 0;
		}
	}
	# run other cycles
	cyclecheck ();
	# send reports
	sendfilereport ();
	# sleep a bit to make sure we don't hog resource if we are not checking files
	sleep 1;
#print STDERR "Reset emptydb / speedfactor: $emptydb / $speedfactor\n";
	$emptydb = 0;
	if ( $filechangecount == 0 ) { $speedfactor = 1; }	# this should be based on completing a run 100% clean (no changes)
	# find cycle time
	$cycletime = int ( ( gettimeofday () - $runtime ) / 360 ) / 10;
#print STDERR "Cycle: $cycletime\n\n";
#exit 0;
}

syslog 'info', 'Exiting';
# cleanup reports as we exit
$lastreport = 0;
$oldestreport = 1;
sendfilereport ();
# one final log check and cleanup reports as we exit
checklogs ();
$loglastreport = 0;
$logoldestreport = 1;
sendlogreport ();
# clean up transactions
$dbh->commit();
# remove PID
if ( $DAEMON ) { unlink $PIDFILE; }



# check other scheduled tasks
sub cyclecheck {
	my $now = time();
	# logcheck cycle
	if ( $now - $lastlogcheck >= $logchecktime ) {
		if ( $now - $lastlogruleupdate >= $logruleupdate ) {
			checklogrules ();
			$lastlogruleupdate = $now;
		}
		checklogs ();
		$lastlogcheck = $now;
		# send reports
		sendlogreport ();
	}
	# pidcheck cycle
	if ( $now - $lastpidcheck >= $pidchecktime ) {
		checkpids ();
		$lastpidcheck = $now;
	}
}



# check a filesystem node (path) against what is in the database
sub checknode {
	my ( $path ) = @_;
#print "\n------------\nProcessing $path\n";
	my @stat;
	if ( -l $path ) {
		@stat = lstat $path;
	} else {
		@stat = stat $path;
	}
	my %fields = (
		'UID' => $stat[4],
		'GID' => $stat[5],
		'Links' => $stat[3],
		'Inode' => $stat[1],
		'Perms' => (defined $stat[2])?sprintf ( '%04o', $stat[2] ):undef,
		'CTime' => $stat[10],
		'Size' => $stat[7],
		'SHA1' => undef,
		'LinkDest' => undef,
	);
	if ( -l $path ) {
		# sumlink
		$fields{'LinkDest'} = readlink $path;
		$fields{'Type'} = 'Symlink';	# overridden by type
	}
	my $size = 0;
	my $changed = 0;
	if ( -f $path ) {
		$size = $stat[7];
		# file
		if ( ! open my $file, '<', $path ) {
			syslog 'err', "ERROR - can't read file \"$path\": $!";
		} else {
			my $buffer = '';
			my $sha1 = Digest::HMAC_SHA1->new;
			my $starttime = gettimeofday ();
			my $totalsize = 0;
			# advise kernel on file access patterns to avoid wasted caching
			IO::AIO::fadvise $file, 0, 0, IO::AIO::FADV_DONTNEED;
			if ( $size <= $smallfiles ) {
#print STDERR "quickread\n";
				# fast read - no delays
				while ( ( my $read = read $file, $buffer, 4096 ) > 0 ) {
					$sha1->add ( $buffer );
				}
			} else {
#print STDERR "slowread\n";
				# slow read - pace ourselves so we don't overload the system
				while ( ( my $read = read $file, $buffer, 4096 ) > 0 ) {
					$sha1->add ( $buffer );
					$totalsize += $read;
					my $reqdelay = $totalsize / ( $byterate * $speedfactor ) + $starttime - gettimeofday ();
					if ( $reqdelay > 0 ) { usleep ( $reqdelay * 1000000 ); }
				}
			}
			close $file;
			$fields{'SHA1'} = $sha1->hexdigest ();
		}
		$fields{'Type'} = 'File';
	} elsif ( -d $path ) {
		# directory
		$fields{'Type'} = 'Dir';
	} elsif ( -p $path ) {
		# FIFO
		$fields{'Type'} = 'FIFO';
	} elsif ( -S $path ) {
		# socket
		$fields{'Type'} = 'Socket';
	} elsif ( -b $path ) {
		# block dev
		$fields{'Type'} = 'BlockDev';
	} elsif ( -c $path ) {
		# char dev
		$fields{'Type'} = 'CharDev';
	} elsif ( ! -e $path and ! -l $path ) {
		# nothing there
		undef %fields;
#print "non-exist: $path\n";
		syslog 'warning', "WARNING - tried to check non-existant node \"$path\"";
	} elsif ( ! -l $path ) {
		# that's weird
		syslog 'err', "ERROR - don't know type for \"$path\"";
		$fields{'Type'} = 'Unknown';
	}
	# check for changes
	my $st = $dbh->prepare ( 'SELECT * FROM NodeInfo WHERE Path = ?' );
	$st->execute ( $path );
#print STDERR "SELECT * FROM NodeInfo WHERE Path = ?\n";
#print STDERR "\t\"".$path."\"\n";
	my $result = $st->fetchrow_hashref ();
#print STDERR "----\n> $path\n";
#foreach (keys %fields) { print STDERR ">> $_ : $fields{$_}\n"; }
#foreach (keys %$result) { print STDERR ">>> $_ : $$result{$_}\n"; }
	if ( defined $$result{'id'} ) {
		my $id = $$result{'id'};
		delete $$result{'id'};
		delete $$result{'Path'};
		delete $$result{'LastChecked'};
		if ( %fields ) {
			# check it's the same node
			foreach my $col (keys %$result) {
				if (
					( defined $$result{$col} xor defined $fields{$col} )
					or ( defined $$result{$col} and defined $fields{$col}
						and $$result{$col} ne $fields{$col} )
					) {
					# file changed
					$speedfactor = $speedup;	# changes - speedup
					++$changed;
					reportfile ( $path, 'Changed', $result, \%fields );
					filechangeaction ( $path, 'Changed', $result, \%fields );
					# update database
					my $cols = 'LastChecked = ?';
					my @params = ( time() );
					foreach (keys %fields) {
						$cols .= ", $_ = ?";
						push @params, $fields{$_};
					}
					push @params, $path;
					foreach ('Size','SHA1','LinkDest') {
						
					}
# TODO what about stuff changed to NULL TODO
					$st = $dbh->prepare ( "UPDATE NodeInfo SET $cols WHERE Path = ?" );
					$st->execute ( @params );
					last;
				}
			}
		} else {
#syslog 'warning', "DB DELETE - tried to check non-existant node \"$path\"";
			# nothing there - node vanished
			$speedfactor = $speedup;	# changes - speedup
			++$changed;
			reportfile ( $path, 'Deleted', $result, undef );
			filechangeaction ( $path, 'Deleted', $result, undef );
			# update database
#print STDERR ">>$path\n";
#print STDERR "DELETE FROM NodeInfo WHERE id = ?\n";
#print STDERR "\t".$id."\n";
			$st = $dbh->prepare ( 'DELETE FROM NodeInfo WHERE id = ?' );
			$st->execute ( $id );
		}
		# update LastChecked
		$st = $dbh->prepare ( 'UPDATE NodeInfo SET LastChecked = ? WHERE Path = ?' );
		$st->execute ( time(), $path );
	} else {
		if ( %fields ) {
			# new node
			$speedfactor = $speedup;	# changes - speedup
			++$changed;
			reportfile ( $path, 'New', undef, \%fields );
			filechangeaction ( $path, 'New', undef, \%fields );
			# add to database
			my $cols = 'Path,LastChecked';
			my $values = '?,?';
			my @params = ( $path, time() );
			foreach (keys %fields) {
				$cols .= ",$_";
				$values .= ',?';
				push @params, $fields{$_};
			}
#print STDERR "INSERT INTO NodeInfo ($cols) VALUES ($values)\n";
#print STDERR "\t".join ( "\n\t", @params )."\n";
			$st = $dbh->prepare ( "INSERT INTO NodeInfo ($cols) VALUES ($values)" );
			$st->execute ( @params );
		} else {
			# nothing exists before or after - no change
		}
	}
	# all done
	return ( $changed, $size );
}


# insert a report row baed on the changes to the file
sub reportfile {
	my ( $path, $event, $before, $after ) = @_;
	if ( $emptydb ) { return; }	# skip on first run
	my $notes = "$event: $path\n";
	if ( defined $before ) {
		foreach my $field (sort keys %$before) {
			my $prev = '';
			my $post = '';
			if ( defined $$before{$field} ) {
				if ( $field eq 'CTime' ) {
					my @localtime = localtime $$before{$field};
					$notes .= sprintf "\t$field: %02d/%02d/%04d %02d:%02d:%02d\n",
								$localtime[3], $localtime[4]+1, $localtime[5]+1900,
								$localtime[2], $localtime[1], $localtime[0];
				} else {
					$notes .= "\t$field: $$before{$field}\n";
				}
				$prev = $$before{$field};
			} else {
				$notes .= "\t$field: NONE\n";
			}
			my $spacer = $field;
			$spacer =~ s/[^ ]/ /g;
			$spacer =~ s/.$/=> /;
			$notes .= "\t$spacer";
			if ( defined $$after{$field} ) {
				if ( $field eq 'CTime' ) {
					my @localtime = localtime $$after{$field};
					$notes .= sprintf "%02d/%02d/%04d %02d:%02d:%02d",
								$localtime[3], $localtime[4]+1, $localtime[5]+1900,
								$localtime[2], $localtime[1], $localtime[0];
				} else {
					$notes .= $$after{$field};
				}
				$post = $$after{$field};
			} else {
				$notes .= 'NONE';
			}
			if ( $prev ne $post ) {
				$notes .= ' **CHANGE**';
			}
			$notes .= "\n";
		}
	} elsif ( defined $after ) {
		foreach (sort keys %$after ) {
			if ( ! defined $$after{$_} ) { next; }
			$notes .= "\t$_: $$after{$_}\n";
		}
	}
	$st = $dbh->prepare ( "INSERT INTO Report (Path,Notes,Time) VALUES (?,?,?)" );
	$st->execute ( $path, $notes, time() );
	$dbh->commit();
	if ( $oldestreport == 0 ) { $oldestreport = time(); }
}


# launch the $filechangeaction on the file with changes to the file in the environment TODO
sub filechangeaction {
	my ( $path, $event, $before, $after ) = @_;
	if ( ! defined ( $filechangeaction ) ) { return 0; }
	my %oldenv = %ENV;
	$ENV{integrityd_event} = $event;
	if ( defined $before ) {
		foreach my $field (sort keys %$before) {
			my $prev = '';
			my $post = '';
			if ( defined $$before{$field} ) {
				$ENV{"integrityd_${field}_before"} = $$before{$field};
				$prev = $$before{$field};
			}
			if ( defined $$after{$field} ) {
				$ENV{"integrityd_${field}_after"} = $$after{$field};
				$post = $$after{$field};
			}
			if ( $prev ne $post ) {
				$ENV{"integrityd_${field}_status"} = 'CHANGE';
			}
		}
	} elsif ( defined $after ) {
		foreach (sort keys %$after ) {
			if ( ! defined $$after{$_} ) { next; }
			$ENV{"integrityd_${_}_after"} = $$after{$_};
		}
	}
	system ( $filechangeaction, $path );
	# TODO check status and lot if bad TODO
}


sub sendfilereport {
	if ( time() - $lastreport < $reportholdoff
		or $oldestreport == 0
		or time() - $oldestreport < $reporttime ) { return; }
	# see what's in the database
	$st = $dbh->prepare ( 'SELECT * FROM Report' );
	$st->execute ();
	$result = $st->fetchall_hashref ( 'id' );
	if ( scalar ( keys %$result ) == 0 ) {
		# nothing to do
		return;
	}
	# it's time to send
	my $host = hostname();
	my $mail;
	if ( ! open $mail, '|-', "$MAIL -s 'Report for $host' '$email'" ) {
		syslog 'err', "ERROR - can't run \"$MAIL -s 'Report for $host' '$email'\": $!";
		return;
	}
	print $mail "Reports from $0 on $host:\n\n";
	foreach my $id ( keys %$result ) {
		my @localtime = localtime $$result{$id}{'Time'};
		printf $mail "At %02d/%02d/%04d %02d:%02d:%02d:\n",
				$localtime[3], $localtime[4]+1, $localtime[5]+1900,
				$localtime[2], $localtime[1], $localtime[0];
		print $mail $$result{$id}{'Notes'}."\n";
	}
	if ( defined $cycletime ) {
		print $mail "\n";
		print $mail "Version: $VERSION\n";
		print $mail "Last Cycle Time: $cycletime hours\n";
		print $mail "Speed Factor: $speedfactor\n";
	}
	close $mail;
	$lastreport = time();
	# clear reports
	$st = $dbh->prepare ( 'DELETE FROM Report' );
	$st->execute ();
	$dbh->commit();
	$oldestreport = 0;
}


sub checklogrules {
	foreach my $area (keys %logrules) {
		my @ruledirs = ('cracking.d','cracking.ignore.d','violations.d','violations.ignore.d');
		my $ruleshome = $area;
		if ( $area =~ /^(\w+):(\/.+)$/ ) {
			push @ruledirs, 'ignore.d.'.$1;
			$ruleshome = $2;
		} else {
			push @ruledirs, 'ignore.d.server';
		}
		# check for removed files
		for my $ruledir (keys %{$logrulestimes{$ruleshome}}) {
			foreach my $file (keys %{$logrulestimes{$ruleshome}{$ruledir}}) {
				if ( ! -f "$ruleshome/$ruledir/$file" ) {
#print STDERR "Remove old \"$ruleshome/$ruledir/$file\"\n";
					delete $logrulestimes{$ruleshome}{$ruledir}{$file};
					delete $logrulesexpressions{$ruleshome}{$ruledir}{$file};
				}
			}
		}
		# check for new/updated files TODO
		for my $ruledir (@ruledirs) {
			opendir my $ls, "$ruleshome/$ruledir" or next;
			while ( defined ( my $file = readdir $ls ) ) {
				if ( $file =~ /^\./ ) { next; }
				if ( ! exists $logrulestimes{$ruleshome}{$ruledir}{$file}
					or $logrulestimes{$ruleshome}{$ruledir}{$file} != -M "$ruleshome/$ruledir/$file" ) {
#print STDERR "Add/Update new \"$ruleshome/$ruledir/$file\"\n";
					# update rules TODO
					open my $rules, '<', "$ruleshome/$ruledir/$file" or next;
					my @rules;
					while ( defined ( my $line = <$rules> ) ) {
						chomp $line;
						if ( $line =~ /^#/ or $line =~ /^\s*$/ ) { next; }
						push @rules, $line;
					}
					close $rules;
					$logrulesexpressions{$ruleshome}{$ruledir}{$file} = \@rules;
					# set new time
					$logrulestimes{$ruleshome}{$ruledir}{$file} = -M "$ruleshome/$ruledir/$file";
				}
			}
			closedir $ls;
		}
	}
}


sub checklogs {
	foreach (keys %logfiles) { checklog ( $_ ); }
	sendlogreport ();
}


sub checklog {
	my ( $logfile ) = @_;
	# check existing position / inode
	$st = $dbh->prepare ( 'SELECT Inode,Position FROM LogPosition WHERE LogFile = ?' );
	$st->execute ( $logfile );
	my $result = $st->fetchrow_hashref ();
	# look at the file
	open my $log, '<', $logfile or return undef;
	my @stat = stat $log;
	my $position = 0;
	if ( defined $$result{'Inode'} and $$result{'Inode'} == $stat[1]
		and defined $$result{'Position'} and $$result{'Position'} <= $stat[7] ) {
		# it's the same file - we can start from where we where
		seek $log, $$result{'Position'}, 0;
		$position = $$result{'Position'};
	}
	# figure out what we are checking against
	my $ruleshome = $logfiles{$logfile};
	my $ignorerule = 'ignore.d.server';
	if ( $ruleshome =~ /^(\w+):(\/.+)$/ ) {
		$ignorerule = 'ignore.d.'.$1;
		$ruleshome = $2;
	}
	# process file
	while ( defined ( my $line = <$log> ) ) {
		if ( $line =~ /\n$/ ) {
			chomp $line;
			$position = tell $log;
			# process the log against the rules
			my $in = 0;
			CR: foreach my $rulesfile (keys %{$logrulesexpressions{$ruleshome}{'cracking.d'}}) {
				foreach my $rule (@{$logrulesexpressions{$ruleshome}{'cracking.d'}{$rulesfile}}) {
					if ( $line =~ /$rule/ ) { $in = 1; last CR; }
				}
			}
			if ( $in ) {
				CRI: foreach my $rulesfile (keys %{$logrulesexpressions{$ruleshome}{'cracking.ignore.d'}}) {
					foreach my $rule (@{$logrulesexpressions{$ruleshome}{'cracking.ignore.d'}{$rulesfile}}) {
						if ( $line =~ /$rule/ ) { $in = 0; last CRI; }
					}
				}
			}
			if ( $in ) {
				# this is a cracking line
				$st = $dbh->prepare ( 'INSERT INTO LogReport (LogFile,Line,Priority) VALUES (?,?,\'cracking\')' );
				$st->execute ( $logfile, $line );
				if ( $logoldestreport == 0 ) { $logoldestreport = time(); }
				next;
			}
			VR: foreach my $rulesfile (keys %{$logrulesexpressions{$ruleshome}{'violations.d'}}) {
				foreach my $rule (@{$logrulesexpressions{$ruleshome}{'violations.d'}{$rulesfile}}) {
					if ( $line =~ /$rule/ ) { $in = 1; last VR; }
				}
			}
			if ( $in ) {
				VRI: foreach my $rulesfile (keys %{$logrulesexpressions{$ruleshome}{'violations.ignore.d'}}) {
					foreach my $rule (@{$logrulesexpressions{$ruleshome}{'violations.ignore.d'}{$rulesfile}}) {
						if ( $line =~ /$rule/ ) { $in = 0; last VRI; }
					}
				}
			}
			if ( $in ) {
				# this is a cracking line
				$st = $dbh->prepare ( 'INSERT INTO LogReport (LogFile,Line,Priority) VALUES (?,?,\'violations\')' );
				$st->execute ( $logfile, $line );
				if ( $logoldestreport == 0 ) { $logoldestreport = time(); }
				next;
			}
			# anything else that should just be ignored
			$in = 1;
			IR: foreach my $rulesfile (keys %{$logrulesexpressions{$ruleshome}{$ignorerule}}) {
				foreach my $rule (@{$logrulesexpressions{$ruleshome}{$ignorerule}{$rulesfile}}) {
					if ( $line =~ /$rule/ ) { $in = 0; last IR; }
				}
			}
			if ( $in ) {
				# this is a cracking line
				$st = $dbh->prepare ( 'INSERT INTO LogReport (LogFile,Line,Priority) VALUES (?,?,\'normal\')' );
				$st->execute ( $logfile, $line );
				if ( $logoldestreport == 0 ) { $logoldestreport = time(); }
				next;
			}
		} else {
			# we got an incomplete line - must be the end
			last;
		}
	}
	close $log;
	# put new position info in the database
	$st = $dbh->prepare ( 'UPDATE LogPosition SET Inode = ?, Position = ? WHERE LogFile = ?' );
	$st->execute ( $stat[1], $position, $logfile );
	$dbh->commit();
}

sub sendlogreport {
	# check what's available
	my $st = $dbh->prepare ( 'SELECT Priority,COUNT(*) FROM LogReport GROUP BY Priority' );
	$st->execute ();
	my $result = $st->fetchall_hashref ( 'Priority' );
	my $mustsend = 0;
	my $now = time();
	# check for cracking - we always send
	if ( defined $$result{'cracking'}{'COUNT(*)'} and $$result{'cracking'}{'COUNT(*)'} > 0 ) { $mustsend = 1; }
	# check for violations - we send if not pooling
	elsif ( defined $$result{'violations'}{'COUNT(*)'} and $$result{'violations'}{'COUNT(*)'} > 0
		and $now - $logoldestreport >= $logreporttime ) { $mustsend = 1; }
	# check for anything to send
	elsif ( defined $$result{'normal'} and $$result{'normal'}{'COUNT(*)'} > 0 
		and $now - $loglastreport >= $logreportholdoff
		and $logoldestreport > 0
		and $now - $logoldestreport >= $logreporttime ) { $mustsend = 1; }
	if ( ! $mustsend ) { return; }
	# see what's in the database
	$st = $dbh->prepare ( 'SELECT * FROM LogReport' );
	$st->execute ();
	$result = $st->fetchall_hashref ( 'id' );
	if ( scalar ( keys %$result ) == 0 ) {
		# nothing to do
		return;
	}
	my %classes;
	foreach my $id ( keys %$result ) {
		$classes{$$result{$id}{'Priority'}}{$$result{$id}{'LogFile'}}{$id} = 1;
	}
	# it's time to send
	my $host = hostname();
	my $mail;
	if ( ! open $mail, '|-', "$MAIL -s 'Log Report for $host' '$email'" ) {
		syslog 'err', "ERROR - can't run \"$MAIL -s 'Log Report for $host' '$email'\": $!";
		return;
	}
	print $mail "LogReports from $0 on $host:\n\n";
	# big one - order by priority, file TODO
	for my $priority ('cracking','violations','normal') {
		for my $logfile (@logfiles) {
			if ( defined $classes{$priority}{$logfile} ) {
				my $header = "$priority :: $logfile :";
				print $mail "$header\n";
				$header =~ s/./-/g;
				print $mail "$header\n";
			} else {
				next;
			}
			for my $id (sort keys %{$classes{$priority}{$logfile}}) {
				print $mail $$result{$id}{'Line'}."\n";
			}
			print $mail "\n\n";
		}
	}
	if ( defined $cycletime ) {
		print $mail "\n";
		print $mail "Version: $VERSION\n";
		print $mail "Last Cycle Time: $cycletime hours\n";
		print $mail "Speed Factor: $speedfactor\n";
	}
	close $mail;
	$loglastreport = $now;
	# clear reports
	$st = $dbh->prepare ( 'DELETE FROM LogReport' );
	$st->execute ();
	$dbh->commit();
	$logoldestreport = 0;
}


sub checkpids {
	my $report = '';
	foreach my $ct (keys %pidfiles) {
		foreach my $pidfile (keys %{$pidfiles{$ct}}) {
			# get last
			$st = $dbh->prepare ( 'SELECT HostPID,CTPID,PidFileExists,Alive,LastChecked FROM PID WHERE File = ?' );
			$st->execute ( $pidfile );
			my $result = $st->fetchrow_hashref ();
			# prep to check current status
			my $pidfileexist = 0;
			my $alive = 0;
			my $pid = 0;
			my $ctpid = 0;
			my $hostpid = 0;
			if ( -f $pidfile ) {
				$pidfileexist = 1;
				open my $pidf, '<', $pidfile;
				$pid = <$pidf>;
				chomp $pid;
				$pid =~ s/^\s+//;
				$pid =~ s/\s+$//;
				close $pidf;
				my $status;
				if ( $ct == 100 ) {
					# host - no PID mapping
					$hostpid = $pid;
					$status = getpidstatus ( $hostpid );
				} else {
					# look at envID (CT) and VPid (PID in CT)
					$ctpid = $pid;
					if ( $$result{'CTPID'} == $ctpid ) {
						# should really re-check
						$hostpid = findctpid ( $ctpid, $ct, $$result{'HostPID'} );
					} else {
						$hostpid = findctpid ( $ctpid, $ct );
					}
					$status = getpidstatus ( $hostpid );
				}
				if ( defined $status and $status ne 'Z' ) {
					$alive = 1;
				}
			}
			# check for status change
			my $change = '';
			# PidFileExists?
			if ( $$result{'PidFileExists'} != $pidfileexist ) {
				if ( $pidfileexist ) {
					$change .= 'PID file created';
				} else {
					$change .= 'PID file removed';
				}
			}
			# Alive?
			if ( $$result{'Alive'} != $alive ) {
				if ( $change ne '' ) { $change .= ' : '; }
				if ( $alive ) {
					$change .= 'Process Started';
				} else {
					$change .= 'Process Stopped';
				}
			}
			if ( $ct == 100 ) {
				# HostPID?
				if ( $$result{'HostPID'} != $hostpid ) {
					if ( $change ne '' ) { $change .= ' : '; }
					if ( $pid ) {
						$change .= 'PID changed from '.$$result{'HostPID'}." to $hostpid";
					} else {
						$change .= "PID $$result{HostPID} removed";
					}
				}
			} else {
				# HostPID?
				if ( $$result{'HostPID'} != $hostpid ) {
					if ( $change ne '' ) { $change .= ' : '; }
					if ( $hostpid ) {
						$change .= 'HostPID changed from '.$$result{'HostPID'}." to $hostpid";
					} else {
						$change .= "HostPID $$result{HostPID} removed";
					}
				}
				# CTPID?
				if ( $$result{'CTPID'} != $ctpid ) {
					if ( $change ne '' ) { $change .= ' : '; }
					if ( $ctpid ) {
						$change .= 'CTPID changed from '.$$result{'CTPID'}." to $ctpid";
					} else {
						$change .= "CTPID $$result{CTPID} removed";
					}
				}
			}
			# did we generate a change?
			if ( $change ne '' ) {
				# get last time
				my $lasttime;
				if ( $$result{'LastChecked'} == 0 ) {
					$lasttime = 'Never';
				} else {
					my @localtime = localtime $$result{'LastChecked'};
					$lasttime = sprintf "%02d/%02d/%04d %02d:%02d:%02d\n",
						$localtime[3], $localtime[4]+1, $localtime[5]+1900,
						$localtime[2], $localtime[1], $localtime[0];
				}
				# put in report
				$report .= "$pidfile:\n\t$change\n\tLast Checked: $lasttime\n";
				# update database
				$st = $dbh->prepare ( 'UPDATE PID SET HostPID = ?, CTPID = ?, PidFileExists = ?, Alive = ?, LastChecked = ? WHERE File = ?' );
				$st->execute ( $hostpid, $ctpid, $pidfileexist, $alive, time(), $pidfile );
			} else {
				# update database LastChecked
				$st = $dbh->prepare ( 'UPDATE PID SET LastChecked = ? WHERE File = ?' );
				$st->execute ( time(), $pidfile );
			}
		}
	}
	# report changes
	if ( $report ne '' ) {
		my $host = hostname();
		my $mail;
		if ( ! open $mail, '|-', "$MAIL -s 'PID Report for $host' '$email'" ) {
			syslog 'err', "ERROR - can't run \"$MAIL -s 'PID Report for $host' '$email'\": $!";
			return;
		}
		print $mail "PIDReports from $0 on $host:\n\n";
		print $mail "$report\n";
		if ( defined $cycletime ) {
			print $mail "\nLast Cycle Time: $cycletime hours\n";
			print $mail "Speed Factor: $speedfactor\n";
		}
		close $mail;
	}
}

sub getpidstatus {
	my ( $pid ) = @_;
	if ( ! defined $pid ) { return undef; }
	open my $st, '<', "/proc/$pid/status" or return undef;
	my $state;
	while ( defined ( my $line = <$st> ) ) {
		if ( $line =~ /^State:\s*(\w)\s+\([\w\s]+\)$/ ) {
			$state = $1;
			last;
		}
	}
	close $st;
	return $state;
}

sub findctpid {
	my ( $ctpid, $ct, $prevhostpid ) = @_;
	# check the previous pid as a shortcut if we can
	if ( defined $prevhostpid
		and open my $st, '<', "/proc/$prevhostpid/status" ) {
		my $envid = 0;
		my $vpid = 0;
		while ( defined ( my $line = <$st> ) ) {
			if ( $line =~ /^envID:\s*(\d+)$/ ) {
				$envid = $1;
			} elsif ( $line =~ /^VPid:\s*(\d+)$/ ) {
				$vpid = $1;
			}
			if ( $vpid == $ctpid and $envid == $ct ) {
				# found it
				return $prevhostpid;
			}
		}
		close $st;
	}
	# search all pids for this ctpid / ct
	foreach my $proc (glob '/proc/*/status') {
		open my $st, '<', $proc or next;
		my $envid = 0;
		my $vpid = 0;
		while ( defined ( my $line = <$st> ) ) {
			if ( $line =~ /^envID:\s*(\d+)$/ ) {
				$envid = $1;
			} elsif ( $line =~ /^VPid:\s*(\d+)$/ ) {
				$vpid = $1;
			}
			if ( $vpid == $ctpid and $envid == $ct
				and $proc =~ /^\/proc\/(\d+)\/status$/ ) {
				# found it
				return $1;
			}
		}
		close $st;
	}
	return 0;	# none found
}


sub exitclean {
	$run = 0;
}




